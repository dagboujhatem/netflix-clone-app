pipeline {
	agent {
		label {
			label ''
			customWorkspace("workspace/${env.JOB_NAME}")
		}
	}
	environment {
		ECR_PRIVATE_REGISTRY_URL = "590184116223.dkr.ecr.eu-west-3.amazonaws.com"
		AWS_DEFAULT_REGION="eu-west-3"
		CREDENTIALS_ID="aws-credentials"
	}
	options {
		buildDiscarder(logRotator(numToKeepStr: "10"))
        timeout(time: 1, unit: 'HOURS')
        disableConcurrentBuilds()
        skipStagesAfterUnstable()
        ansiColor('xterm')
		timestamps()
	}

	stages {
		stage('Initialisation') {
			steps {
				script {
					echo 'Step 1: Retrieving changelist and revision numbers from POM file'
					env.REVISION = readMavenPom().getProperties().getProperty("revision")
					env.CHANGELIST = readMavenPom().getProperties().getProperty("changelist")

					if (env.CHANGELIST == "-SNAPSHOT") {
						env.DOCKER_REG_ENV = 'stages'
						if (env.BRANCH_NAME.contains('RC_') || env.BRANCH_NAME.contains('hotfix_')) {
							// We're on a branch destined to be delivered
							env.POM_VERSION = "${env.REVISION}${env.CHANGELIST}"
						} else {
							// We're on a separate branch in snapshot, use the branch name
							env.POM_VERSION = "${env.BRANCH_NAME}${env.CHANGELIST}".replace('/','_')
						}
					} else if (env.CHANGELIST == "-RELEASE") {
						env.DOCKER_REG_ENV = 'releases'
						if (env.BRANCH_NAME.contains('RC_') || env.BRANCH_NAME.contains('hotfix_')) {
							env.POM_VERSION = "${env.REVISION}${env.CHANGELIST}"
						} else {
							error "The branch cannot be a RELEASE branch, please create a RC_ or a hotfix_"
						}
					} else {
						error "The changelist must be either -SNAPSHOT or -RELEASE"
					}

					echo "‚úÖ This version is: ${env.POM_VERSION}"
					withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: "${CREDENTIALS_ID}"]]) {
						loginToAWSAndECR(env.AWS_DEFAULT_REGION, env.ECR_PRIVATE_REGISTRY_URL)
					}
				}
			}
		}
		stage('Build') {
			steps {
				echo 'Building the project...'
				sh "mvn -am -amd versions:set -DnewVersion=${env.POM_VERSION}"
                sh "mvn -am -amd clean install"
			}
		}
		stage('Unit Test') {
            steps {
       				echo 'Running unit tests...'
       				sh "mvn clean test"
       			}
            post {
                always {
                    script {
                        try {
                            // Collects unit test reports
                            junit '**/target/surefire-reports/*.xml'
                            // Generate and archive the unit test report in HTML
                            sh 'mvn surefire-report:report'
                            archiveArtifacts artifacts: 'target/site/*.html', fingerprint: true
                        } catch (Exception e) {
                            echo "No test reports found. Skipping test results publishing."
                        }
                    }
                }
                failure {
                    echo 'Unit tests failed!'
                }
            }
		}
		stage('Integration Test') {
			steps {
				echo 'Running unit tests...'
				sh "mvn clean verify -DskipTests" // Runs only integration tests
			}
			post {
				always {
					script {
						try {
							// Collects integration test reports
							junit '**/target/surefire-reports/*.xml'
							// Generate and archive the integration test report in HTML
                            sh 'mvn failsafe-report:report'
                            archiveArtifacts artifacts: 'target/site/*.html', fingerprint: true
						} catch (Exception e) {
							echo "No test reports found. Skipping test results publishing."
						}
					}
				}
				failure {
                    echo 'Integration tests failed!'
                }
			}
		}

		stage('Static Analysis') {
			steps {
				script {
					echo 'Running static code analysis...'
					try{
						/*
						sh "mvn clean verify sonar:sonar \
                      -Dsonar.projectKey=netflix-clone-app \
                      -Dsonar.host.url=http://13.38.181.68:9000 \
                      -Dsonar.login=06349f961e402982d41a1409dd533a32192ab729"
                      */
					}catch (Exception e) {
						echo "SonarQube scan impossible."
					}
				}
			}
		}
		stage('Build image') {
			steps {
				script {
					echo 'Find Jar files for this application...'
					//archiveArtifacts artifacts: '**/target/*.jar', fingerprint: true // Archive les JAR
					def additional_services = ["netflix-api-gateway", "netflix-service-discovery"]
					def jar_files = []
					sh(script: 'find ./*-service/ -name *.jar', returnStdout: true).trim().split('\n').each { jar_files << it }
					// add additional_services to jar_files
					additional_services.each{ service ->
						sh(script: """find ./$service/ -name '*.jar'""", returnStdout: true).trim().split('\n').each { jar_files << it }
					}

					echo 'Building, tagging & Push the Docker Image to AWS private registry (AWS ECR) ...'
					def dockerTasks = jar_files.collectEntries{jar_file -> ["${jar_file.split('/')[1]}": {
						def service_name = jar_file.split('/')[1]
						def jar_file_path = jar_file.split('/' + service_name)[1]
						def ecrRepoName = "${service_name}-${env.DOCKER_REG_ENV}"
						def ecrRepoURL = "${env.ECR_PRIVATE_REGISTRY_URL}/${ecrRepoName}"
						ensureEcrRepositoryExists("${ecrRepoName}")
						echo "üöÄ Building Docker image for ${service_name} ..."
						sh "docker build -t '${ecrRepoURL}:${env.POM_VERSION}' -f ./.docker/Dockerfile --no-cache --build-arg JAR_FILE=${jar_file_path} ./${service_name}"
						echo "pushing image ${service_name}:${env.POM_VERSION}"
						sh "docker push '${ecrRepoURL}:${env.POM_VERSION}'"
						echo "‚úÖ ${service_name} has been pushed to ${env.DOCKER_REG_ENV} repository."
						}]
					}
					parallel dockerTasks
				}
			}
		}

	}
	post {
		always {
			script{
				if (getContext(hudson.FilePath)) {
					// Suppression du workspace jenkins
					deleteDir()
					// Clean up the Docker system in order to tackle it.
					// The following command can be used to remove unused images only  (i.e. not referenced by any container) including dangling ones
					// You can use the -a flag (short for --all) as follows:
					sh "docker image ls"
					sh("sudo sh -c 'yes | docker system prune -a'")
				}
			}
		}
	}
}
def loginToAWSAndECR(String awsRegion, String ecrRepo){
	try{
		// Execute shell commands for AWS authentication and Docker login
		sh """
			echo "üîê Logging in to AWS ECR..."
            aws ecr get-login-password --region ${awsRegion} | docker login --username AWS --password-stdin ${ecrRepo}
        """
		println "‚úÖ Successfully logged in to AWS ECR (${ecrRepo})"

	}catch (Exception e) {
		println "‚ö†Ô∏è Error: ${e.message}"
	}
}

def ensureEcrRepositoryExists(String repoName) {
	try {
		def awsRegion = env.AWS_DEFAULT_REGION  ?: "eu-west-3"
		def ecrRepoBase = env.ECR_PRIVATE_REGISTRY_URL ?: "590184116223.dkr.ecr.eu-west-3.amazonaws.com"

		echo "üîç Checking if ECR repository '${repoName}' exists..."

		def checkRepoCmd = "aws ecr describe-repositories --repository-names ${repoName} --region ${awsRegion} 2>/dev/null"
		def checkRepoStatus = sh(script: checkRepoCmd, returnStatus: true)

		if (checkRepoStatus == 0) {
			echo "‚úÖ ECR repository '${repoName}' already exists."
		} else {
			echo "‚ö†Ô∏è Repository '${repoName}' not found. Creating it now..."
			sh """
                aws ecr create-repository --repository-name ${repoName} --region ${awsRegion}
            """
			echo "üéâ Repository '${repoName}' created successfully!"
		}
	} catch (Exception e) {
		error "‚ùå Error: ${e.message}"
	}
}
